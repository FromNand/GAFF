【注意書き】
このメモでいうカーネルとは、断っていない限りOSイメージからIPLを覗いたものを言います。
パーティションという単語は、パーティション区画分けされたデータの中に存在するOSイメージを指して使用していることがあります。
セグメントという単語は、x86におけるセグメント機構とローダが参照するセグメントの2つの意味で使用しています。(これらは同じ意味を指すこともありますが...)

【掲示板の中で読むべきページ】
http://hrb.osask.jp/wiki/?members      (いろんな方の個人ページ)
http://hrb.osask.jp/wiki/?faq          (Q&Aのまとめ)
http://hrb.osask.jp/wiki/?q_and_a      (Q&Aのアーカイブ)
http://hrb.osask.jp/wiki/?mistakes     (本の中の間違えについて、議論している)
http://hrb.osask.jp/wiki/?bugs         (上にほぼ同じ)
http://hrb.osask.jp/wiki/?impressions  (自作OSについての質問)
http://hrb.osask.jp/wiki/?challengers  (30日でチャレンジしている人たち)
http://hrb.osask.jp/wiki/?ReadersOS    (読者が作ったいろんなOS)
http://hrb.osask.jp/wiki/?tools        (筆者作のツールについて)
http://hrb.osask.jp/wiki/?advance      (★本の続きの発展的な内容)
http://hrb.osask.jp/wiki/?Athlon64X2   (hariboteOSが一部機種で動かない理由)
http://hrb.osask.jp/wiki/?guide        (書籍を実際に書いてみる人が間違えないために)

【ほしいもの】
・外付けHDD
・SDカードとそのカードリーダー(ジャンクPCの方にリーダーが無いため)
・FDとUSB-FDがほしい

【ちょっと大きめの課題】
１.ブログの内容を読み返す。
２.OS.dev.orgのサイトや、カーネルハッキングのサイト、川合秀美さんの掲示板などのOSまとめ記事を読み込む。
３.作りながら学ぶOSを読んで、実際に試す。
４.大神さんの同人誌「x86機械語入門」を読みたい。

【小さめの課題】

★★★ リアルモードからプロテクテッドモードに切り替わった直後のセグメントレジスタの動作 ★★★
>>> リアルモードからプロテクテッドモードに切り替わった直後、セグメントレジスタはリアルモードのときと同じ動作をする。
>>> これはプロテクテッドモードに移行するまで、プログラムをなんとか実行するため。
>>> 具体的には、セグメントレジスタに値を代入したときにプロテクテッドモードのセグメント機構が働くようになる。
>>> IPLのプログラムをいじくり回して、実際に確認した。

★★★ イメージファイルのサイズを小さくする ★★★
>>> 簡単にできるのは、.bssや.COMMONを抜いてしまうこと。
>>> これらを.dataセグメントから排除すると60kb以上のデータ領域が不必要になり、OSのロード時間の大幅な短縮になる。
>>> しかし、この場合リンカはどのように.bss系の変数をリンクするのだろうか？
>>> mapファイルを覗いてみると、.rodataのあとにきちんと並べられているようだ。
>>> しかし、実際のファイルにはその領域を確保しない。完璧だ。

☆☆☆ .bss領域のサイズをリンカスクリプトから取得したい ☆☆☆
>>> .bssや.COMMONをファイルに保存せずにOSから利用する方法がわかり、ファイルサイズは大幅に小さくなった。
>>> ただ、.bss領域のサイズをリンカスクリプトからC言語に知らせる機能がわからない。
>>> セグメント単位のサイズなら、リンカスクリプトでSIZEOF()を使えばいいのだが、セクション単位だとわからない。
>>> 一応、mapファイルを見るとVMA・LMA・サイズなどの情報はきちんと書いてあるようだ。
>>> でも、これでいちいち調べるのは不便だと思う。
>>> 例えば、もしOSのデータ領域を他の場所にロードし直すときなどには、リンカスクリプトから情報が得たくなると思う。

★★★ 自作のフォーマットでもいいから、パーティションを作成したい ★★★
★★★ ブートローダで1-5程度の数字をキーボードから打ち込んだら、そのOSが起動するみたいな ★★★
>>> 4つ以下のOSイメージを指定すると、それらのイメージを組み合わせたイメージを作成するソフトを完成させた。
>>> 具体的には、そのソフトウェアは次のような動作をする。
>>> １．1セクタ目にパーティションを選択して、PBR(1セクタ分だけ)をロードする機能をもったMBRをもたせる。(とりあえず、MBRは512個のchar配列に保存しておく。)
>>> ２．指定された4つ以下のOSイメージをそれぞれ解析して、そのサイズを調べる。
>>> ３．2で各パーティションのオフセット・サイズは分かるので、これをMBRの中のパーティションの情報の部分に書き込んでおく。(存在するかどうかのフラグも持たせてある。)
>>> ４. PBRも自身のカーネルが起動ディスクの中でのオフセットとサイズは必要なので、2の情報をPBRにも書き込んでおく。(PBRは各パーティションの1セクタ目。)
>>> こうすることで何が起こるのかというと、各OSイメージはそのままディスクに焼いた場合、普通にOSとして起動される。
>>> これは、PBRがIPLの役割を果たすから。
>>> そして、パーティション作成ソフトを使用した場合は、そのイメージからPCを起動すると、まずMBRがBIOSから呼び出される。
>>> そして、MBRの中には各パーティションの情報があるので、その情報を頼りにパーティションを選択し起動する。
>>> つまり、OSイメージはMBRのことを"ほぼ"意識せずに作成することができる。
>>> しかし、OSの中で一つだけ制約ができてしまう。実は、IPLの部分だけは少しMBRに合わせる必要がある。
>>> 具体的には、OSイメージの1セクタ目のオフセット0x1f6にはカーネルのオフセットを、0x1faにはカーネルのサイズを格納する必要がある。
>>> この部分は、パーティション作成ソフトによって上書きされる可能性のある部分でもある。
>>> そして、IPLはその部分を参照してLBA方式でカーネルをロードする必要がある。
>>> こういった成約をIPLに課すことで、MBRからOSを選択することが可能になる。

★★★ USBブートでBIOSに何度もアクセスせずに一気にメモリに読み込みたい ★★★
>>> 16セクタ単位で読み込むIPLを作成することに成功した。
>>> まず、僕が作成しているOSのIPLは0x1f6に起動ディスクにおけるカーネルのオフセット、0x1faにカーネルのサイズが格納されている。
>>> この情報を頼りに、IPLはカーネルをロードする。
>>> 次に、int 0x12を使用して、リアルモードにおけるコンベンショナルメモリの範囲を確認する。
>>> int 0x12で得られるアドレスは÷1024された値であるため、この値に2をかけるとセクタ単位に変換できる。
>>> さらにこの値から、カーネルがロードされるアドレスをセクタ単位にしたものを引く。
>>> これで、リアルモードにおいてカーネルが使用できるメモリのサイズが完全に分かる。
>>> ここで求めた、カーネルの利用できる領域のサイズとカーネルの実際のサイズを比較して、カーネルのほうが大きかった場合エラーにする。
>>> さて、16セクタ単位でカーネルをロードしようと思うと、カーネルのサイズが1-16セクタなら1回、17-32セクタなら2回、33-48セクタなら3回...必要になる。
>>> 今、カーネルのサイズは得られているので、この値に15を足したあと、16で割る。すると、カーネルサイズをロード回数にに変換することができる。
>>> あとは拡張INT0x13で読み出していく。この際、16セクタ単位で読み出しているので、ロード先のアドレスに0x2000足すことを忘れずに。

☆☆☆ 浮動小数点数の機械語を使えるようにする ☆☆☆
>>> これは「http://hrb.osask.jp/wiki/?advance/FPU」を参考にすると良い。

★★★ プロテクテッドモードのセグメントの属性について、色々実験したい ★★★
>>> 実験した結果を書いておく。
>>> データセグメントを実行するとエラー。
>>> 32bit用に生成された機械語を16bitのコードセグメントで実行するとエラー。
>>> コードセグメントに書き込むとエラー。
>>> 最も面白かった結果は、プロテクテッドモード移行直後に.code32としなければエラーが出ていたプログラムにおいて、
>>> コードセグメントを32biセグメントから16bitセグメントに変えたところ、.code16のまま実行できてしまったこと。
>>> でも、.code16のままだと、うまくやらないとC言語で書いたカーネルが動かないだろうし、CPUを腐らしてしまう事になりそう。

☆☆☆ bootinfo構造体のvmodeの部分を2byteにしたい ☆☆☆
>>> どうぞ。

☆☆☆ VESAを使用しない(VESA ver 2.0以前？)の画面モードに適応させる ☆☆☆
>>> どうぞ。

☆☆☆ UEFIやGRUBについて勉強する ☆☆☆
>>> どうぞ。

☆☆☆ FD, CD, DVD, USB, SD, 外付けHDD, 内蔵HDDでブートしたい ☆☆☆
>>> フロッピーディスクが0x00, 0x01, 0x02...と連番が振られていくのに対して、HDD系デバイスは0x80, 0x81, 0x82...と連番が振られていくことだけはわかった。

☆☆☆ FAT形式でないイメージファイルでCDブートができないのはなぜ？ ☆☆☆
☆☆☆ USBではFAT形式でなくてもいいのに ☆☆☆
>>> 自作ツールを作るしかないか？

★★★ OSイメージをFAT形式にするのって、どんな意味があるの？ ★★★
>>> おそらく、windowsやlinuxといったOSでディスクを認識してもらうため。
>>> BIOSはFAT形式とか関係なく、起動ディスクの先頭セクタを0x7c00に展開する。

☆☆☆ C++でOS開発 ☆☆☆
>>> まぁ、気が向いたらね...

☆☆☆ CのnewlibなどをビルドしてOSに組み込む ☆☆☆
>>> 一回自分のライブラリを作ってから。

☆☆☆ フルアセンブラ ☆☆☆
>>> まともにOSが作れるようになってから。

☆☆☆ RWのCDが届いたら、USB用のIPLのドライブの部分を、0x80から0x00にして起動してみると起動できるかも？ ☆☆☆
☆☆☆ LBAはどのディスクでも使える？ということが知りたい ☆☆☆
>>> わからん。

★★★ テキストモードで色々実験する ★★★
>>> 作りながら学ぶOSカーネルという本ではカラーテキストVRAM(0xb8000-0xbffff)を使用しているが、
>>> 一文字2byteを使用して、1byte目にアスキーコード、2byte目に背景色や文字色といったアトリビュートを設定するみたい。
>>> 0xb8000からのVRAMだと、80*25=2000文字まで表示できるみたい。
>>> 一文字2byteで2000文字まで表示できるので、スクリーン一杯に文字を表示するには、2*2000=4000byte使用する。
>>> これは0xfa0バイト。0xbffff-0xb8000=0x7fffであり、VRAMは0x7fffバイトも使えるのにもったいない。
>>> 昔はページ単位(4kb)で分けて使用されていたらしいが、最近では先頭の0xfa0バイトしか使わないらしい。

☆☆☆ 起動デバイスを選択する ☆☆☆
>>> とりあえず、FDは0x00, 0x01...でHDD系は0x80, 0x81...になっているようだが。

☆☆☆ .isoに変換せずに.imgのまま、CDブートしたい ☆☆☆
☆☆☆ fdtoisoは何をやっているのか ☆☆☆
>>> がんばれ。

☆☆☆ CDをUSBケーブルでつないだら、どんなIPLが必要？ ☆☆☆
>>> 当然CD用のものだと思うけど、実験してみないと何が起こるかわからない。

☆☆☆ IntelCPUの資料を読み込む ☆☆☆
>>> これだいじ。

☆☆☆ MMX命令を使用したい ☆☆☆
>>> だいぶ先になるかも。

☆☆☆ カーネルを一度で読み込みたい ☆☆☆
>>> プロテクテッドモードからBIOSが呼び出せないので、デバイスドライバがかけるようにならないと実現できない。
>>> 一応考えてみると、IPLからセカンドローダを呼び出し、セカンドローダの中でプロテクテッドモードに移行する。
>>> ここで、自分で書いたデバイスドライバを用いて起動ディスクにアクセスしてカーネルをロードする。
>>> 書くのは簡単なんだよなぁ。。。